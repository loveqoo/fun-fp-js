/**
 * Fun FP JS - A Lightweight Functional Programming Library
 * UMD (Universal Module Definition) + ESM build
 * 
 * Built: 2026-01-02 00:50:59 (Asia/Seoul)
 * 
 * Supports: CommonJS, AMD, Browser globals, ES Modules
 * 
 * Auto-generated by build.js - DO NOT EDIT DIRECTLY
 * Edit modules/*.js files instead and run: node build.js
 */
(function (root, factory) {
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = factory();
        module.exports.default = module.exports;
    } else if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else {
        root.funFpJs = factory();
    }
})(typeof self !== 'undefined' ? self : this, function () {
    'use strict';
    var cachedInstance = null;
    var funFpJs = function (dependencies, cacheable) {
        if (cacheable === undefined) cacheable = true;
        if (cacheable && cachedInstance) return cachedInstance;
        dependencies = dependencies || {};

        // ========== CORE ==========
        const isFunction = f => typeof f === 'function';
        const log = dependencies.enableLog === false ? () => { } : (isFunction(dependencies.log) ? dependencies.log : console.log);
        const Types = { Functor: Symbol.for('fun-fp-js/Functor'), Applicative: Symbol.for('fun-fp-js/Applicative'), Monad: Symbol.for('fun-fp-js/Monad') };
        const raise = e => { throw e; };
        const typeOf = a => {
            switch (typeof a) {
                case 'undefined': return 'undefined';
                case 'boolean': return 'boolean';
                case 'number': return 'number';
                case 'string': return 'string';
                case 'symbol': return 'symbol';
                case 'function': return 'function';
                case 'object': return a === null ? 'null' : ((a.constructor && a.constructor.name) || 'object')
                default: return 'unknown';
            }
        };
        const isPlainObject = a => typeof a === 'object' && a !== null && !Array.isArray(a) && Object.getPrototypeOf(a) === Object.prototype;
        const isIterable = a => a != null && typeof a[Symbol.iterator] === 'function';
        const toIterator = function* (iterable) {
            if (iterable == null) return;
            if (isIterable(iterable)) {
                yield* iterable;
            } else if (isPlainObject(iterable)) {
                for (const key in iterable) {
                    if (Object.prototype.hasOwnProperty.call(iterable, key)) {
                        yield iterable[key];
                    }
                }
            } else {
                yield iterable;
            }
        };
        const expectedFunction = expected => name => (...fs) => {
            const invalids = fs.map((f, i) => [i, f]).filter(([_, f]) => !isFunction(f)).map(([i, f]) => `argument ${i} is ${typeOf(f)}`);
            if (invalids.length > 0) raise(new TypeError(`${name}: expected ${expected}, but ${invalids.join(', ')}`));
            return fs; // array
        };
        const expectedFunctions = {
            'core:a-function': expectedFunction('a function'),
            'core:extracts-to-be-functions': expectedFunction('extracts to be functions'),
            'core:on-error-to-be-a-function': expectedFunction('onError to be a function'),
            'core:all-arguments-to-be-functions': expectedFunction('all arguments to be functions'),
            'core:all-branch-arguments-to-be-functions': expectedFunction('all branch arguments to be functions'),
            'core:check-to-be-a-function': expectedFunction('check to be a function'),
            'core:lift-to-be-a-function': expectedFunction('lift to be a function'),
            'core:transducer-to-be-a-function': expectedFunction('transducer to be a function'),
            'core:reducer-to-be-a-function': expectedFunction('reducer to be a function'),
        };
        const hasFunctions = (extracts, check = _ => true) => obj => obj
            && expectedFunctions['core:extracts-to-be-functions']('hasFunction')(...extracts).every(extract => isFunction(extract(obj)))
            && check(obj);
        const runCatch = (f, onError = e => log(e)) => {
            expectedFunctions['core:a-function']('runCatch:f')(f);
            expectedFunctions['core:on-error-to-be-a-function']('runCatch:onError')(onError);
            return (...args) => {
                try {
                    return f(...args);
                } catch (e) {
                    return onError(e);
                }
            };
        };
        const isFunctor = hasFunctions([obj => obj.map], obj => obj[Types.Functor]);
        const isApplicative = hasFunctions([obj => obj.map, obj => obj.ap], obj => obj[Types.Functor] && obj[Types.Applicative]);
        const isMonad = hasFunctions([obj => obj.map, obj => obj.flatMap], obj => obj[Types.Functor] && obj[Types.Monad]);
        const identity = x => x;
        const constant = x => () => x;
        const tuple = (...args) => args;
        const apply = f => {
            expectedFunctions['core:a-function']('apply')(f);
            return args => {
                if (!Array.isArray(args)) {
                    raise(new TypeError(`apply: expected an array of arguments, but got ${typeOf(args)}`));
                }
                return f(...args);
            };
        };
        const apply2 = f => {
            expectedFunctions['core:a-function']('apply2')(f);
            return args => {
                if (!Array.isArray(args) || args.length !== 2) {
                    raise(new TypeError(`apply2: expected an array of exactly 2 arguments, but got ${Array.isArray(args) ? args.length : typeOf(args)}`));
                }
                return f(args[0], args[1]);
            };
        };
        const unapply = f => (expectedFunctions['core:a-function']('unapply')(f), (...args) => f(args));
        const unapply2 = f => (expectedFunctions['core:a-function']('unapply2')(f), (a, b) => f([a, b]));
        const curry = (f, arity = f.length) => {
            expectedFunctions['core:a-function']('curry')(f);
            return function _curry(...args) {
                return args.length >= arity ? f(...args) : (...next) => _curry(...args, ...next);
            };
        };
        const curry2 = f => (expectedFunctions['core:a-function']('curry2')(f), a => b => f(a, b));
        const uncurry = f => {
            expectedFunctions['core:a-function']('uncurry')(f);
            return (...args) => args.reduce((acc, arg, i) => {
                if (!isFunction(acc)) {
                    raise(new TypeError(`uncurry: expected a curried function (function returning functions), but got ${typeOf(acc)} before applying argument ${i}`));
                }
                return acc(arg);
            }, f);
        };
        const uncurry2 = f => {
            expectedFunctions['core:a-function']('uncurry2')(f);
            return (a, b) => {
                const next = f(a);
                if (!isFunction(next)) {
                    raise(new TypeError(`uncurry2: expected a curried function (function returning a function), but got ${typeOf(next)}`));
                }
                return next(b);
            };
        };
        const partial = (f, ...args) => (expectedFunctions['core:a-function']('partial')(f), (...next) => f(...args, ...next));
        const predicate = (f, fallbackValue = false) => {
            expectedFunctions['core:a-function']('predicate')(f);
            return (...args) => {
                const result = runCatch(f, _ => fallbackValue)(...args);
                if (result instanceof Promise || (result && typeof result.then === 'function')) {
                    log(new TypeError('predicate: Async functions (Promises) are not supported in sync predicate.'));
                    return Boolean(fallbackValue);
                }
                return Boolean(result);
            };
        };
        const negate = f => (expectedFunctions['core:a-function']('negate')(f), (...args) => !f(...args));
        const flip = f => (expectedFunctions['core:a-function']('flip')(f), (...args) => f(...args.slice().reverse()));
        const flip2 = f => (expectedFunctions['core:a-function']('flip2')(f), (a, b, ...args) => f(b, a, ...args));
        const flipC = f => (expectedFunctions['core:a-function']('flipC')(f), a => b => f(b)(a));
        const flipCV = f => (expectedFunctions['core:a-function']('flipCV')(f), (...as) => (...bs) => f(...bs)(...as));
        const pipe = (...fs) => {
            if (fs.length === 0) return identity;
            expectedFunctions['core:all-arguments-to-be-functions']('pipe')(...fs);
            return x => fs.reduce((acc, f) => f(acc), x);
        };
        const pipe2 = (f, g) => pipe(f, g);
        const compose = (...fs) => pipe(...fs.slice().reverse());
        const compose2 = (f, g) => compose(f, g);
        const once = (f, option = {}) => {
            expectedFunctions['core:a-function']('once')(f);
            const state = option.state || { called: false };
            const defaultValue = option.defaultValue;
            let result = defaultValue;
            return (...args) => {
                if (!state.called) {
                    const val = f(...args);  // 예외 발생 시 called가 true가 되지 않음
                    result = val;
                    state.called = true;
                }
                return result;
            };
        };
        const converge = (f, ...branches) => {
            expectedFunctions['core:a-function']('converge:f')(f);
            expectedFunctions['core:all-branch-arguments-to-be-functions']('converge:branches')(...branches);
            return (...args) => f(...branches.map(branch => branch(...args)));
        };
        const runOrDefault = fallbackValue => g => isFunction(g) ? runCatch(g, _ => fallbackValue)() : fallbackValue;
        const capture = (...args) => (f, onError = e => log(e)) => runCatch(f, onError)(...args);
        const tap = (...fs) => {
            expectedFunctions['core:all-arguments-to-be-functions']('tap')(...fs);
            return x => {
                const runAgainstX = f => runCatch(f)(x);
                fs.forEach(runAgainstX);
                return x;
            };
        };
        const also = flipCV(tap);
        const into = flipCV(pipe);
        const useOrLift = (check, lift) => {
            expectedFunctions['core:check-to-be-a-function']('useOrLift:check')(check);
            expectedFunctions['core:lift-to-be-a-function']('useOrLift:lift')(lift);
            return x => predicate(check)(x) ? x : lift(x);
        };
        const useArrayOrLift = useOrLift(Array.isArray, Array.of);
        const range = n => n >= 0 ? Array.from({ length: n }, (_, i) => i) : [];
        const rangeBy = (start, end) => start >= end ? [] : range(end - start).map(i => start + i);
        const { transducer } = (() => {
            class Reduced {
                constructor(value) { this.value = value; }
                static of(value) { return new Reduced(value); }
                static isReduced(value) { return value instanceof Reduced; }
            }
            const transduce = transducer => {
                expectedFunctions['core:transducer-to-be-a-function']('transducer.transduce:transducer')(transducer);
                return reducer => {
                    expectedFunctions['core:reducer-to-be-a-function']('transducer.transduce:reducer')(reducer);
                    return initialValue => collection => {
                        if (!isIterable(collection)) {
                            raise(new TypeError(`transduce: expected an iterable, but got ${typeof collection}`));
                        }
                        const transformedReducer = transducer(reducer);
                        let accumulator = initialValue;
                        for (const item of collection) {
                            accumulator = transformedReducer(accumulator, item);
                            if (Reduced.isReduced(accumulator)) {
                                return accumulator.value;
                            }
                        }
                        return accumulator;
                    };
                };
            };
            const map = f => (expectedFunctions['core:a-function']('transducer.map')(f), reducer => (acc, val) => reducer(acc, f(val)));
            const filter = p => (expectedFunctions['core:a-function']('transducer.filter')(p), reducer => (acc, val) => p(val) ? reducer(acc, val) : acc);
            const take = count => {
                if (typeof count !== 'number' || !Number.isInteger(count) || count < 1) {
                    raise(new TypeError(`transducer.take: expected a positive integer (>= 1), but got ${count}`));
                }
                return reducer => {
                    let taken = 0;
                    return (accumulator, value) => {
                        if (taken < count) {
                            taken++;
                            const result = reducer(accumulator, value);
                            return taken === count ? Reduced.of(result) : result;
                        }
                        return Reduced.of(accumulator);
                    };
                };
            };
            return {
                transducer: {
                    Reduced, of: Reduced.of, isReduced: Reduced.isReduced, transduce, map, filter, take,
                },
            };
        })();

        // ========== EITHER ==========
        expectedFunctions['either:condition-to-be-a-function'] = expectedFunction('condition to be a function');
        expectedFunctions['either:onerror-to-be-a-function'] = expectedFunction('onError to be a function');
        const hasConcat = hasFunctions([obj => obj.concat]);
        const normalizeToError = e => e instanceof Error ? e : new Error(typeof e === 'string' ? e : 'Left Error', { cause: e });
        const toEitherErrorArray = e => useArrayOrLift(e).map(normalizeToError);
        class Either {
            static of(x) { return new Right(x); }
            static right(x) { return new Right(x); }
            static left(e) { return new Left(toEitherErrorArray(e)); }
            static from(x) {
                if (x instanceof Left || x instanceof Right) return x;
                return Either.right(x);
            }
            static fromNullable(x) {
                if (x === null || x === undefined) {
                    return Either.left(new Error(`fromNullable: expected a value, got ${x}`));
                }
                if (x instanceof Left || x instanceof Right) return x;
                return Either.right(x);
            }
            static catch(f, lift = Either.right) {
                expectedFunctions['core:a-function']('Either.catch:f')(f);
                return runCatch(compose(lift, f), Either.left);
            }
            static validate(condition, onError) {
                expectedFunctions['either:condition-to-be-a-function']('Either.validate:condition')(condition);
                expectedFunctions['either:onerror-to-be-a-function']('Either.validate:onError')(onError);
                return x => predicate(condition)(x)
                    ? Either.right(x)
                    : runCatch(compose(Either.left, onError), Either.left)(x);
            }
            static validateAll(list) {
                return useArrayOrLift(list).reduce((acc, x) => {
                    Either.checkEither(x);
                    return Either.right(a => b => [...a, b]).ap(acc).ap(x);
                }, Either.right([]));
            }
            static sequence(list) {
                let acc = [];
                for (const x of useArrayOrLift(list)) {
                    Either.checkEither(x);
                    if (x instanceof Right) {
                        acc.push(x.value);
                    } else {
                        return x;
                    }
                }
                return Either.right(acc);
            }
            static pipeK(...fs) {
                if (fs.length === 0) return Either.from;
                expectedFunctions['core:all-arguments-to-be-functions']('Either.pipeK')(...fs);
                return (x, lift = Either.from) => fs.reduce((acc, f) => acc.flatMap(f), lift(x));
            }
            static traverse(f) {
                expectedFunctions['core:a-function']('Either.traverse')(f);
                return list => Either.sequence(useArrayOrLift(list).map(f));
            }
            static traverseAll(f) {
                expectedFunctions['core:a-function']('Either.traverseAll')(f);
                return list => Either.validateAll(useArrayOrLift(list).map(f));
            }
            static checkEither(v) {
                return (v instanceof Left || v instanceof Right)
                    ? v : raise(new Error(`checkEither: expected Either, got ${typeof v}`));
            }
        }

        class Left extends Either {
            constructor(value) {
                super();
                this.value = value;
                this[Symbol.toStringTag] = 'Left';
                this[Types.Functor] = true;
                this[Types.Applicative] = true;
                this[Types.Monad] = true;
            }
            map() { return this; }
            mapLeft(f) { return compose(Either.left, runCatch(f, identity))(this.value); }
            flatMap() { return this; }
            filter() { return this; }
            fold(onLeft, _) { return expectedFunctions['core:a-function']('Left.fold:onLeft')(onLeft)[0](this.value); }
            ap(v) { return (v instanceof Left && hasConcat(this.value) && hasConcat(v.value)) ? Either.left(this.value.concat(v.value)) : this; }
            getOrElse(v) { return v; }
            isLeft() { return true; }
            isRight() { return false; }
            tapLeft(f) { runCatch(f)(this.value); return this; }
        }

        class Right extends Either {
            constructor(value) {
                super();
                this.value = value;
                this[Symbol.toStringTag] = 'Right';
                this[Types.Functor] = true;
                this[Types.Applicative] = true;
                this[Types.Monad] = true;
            }
            map(f) { return Either.catch(f)(this.value); }
            mapLeft() { return this; }
            flatMap(f) { return runCatch(compose(Either.checkEither, f), Either.left)(this.value); }
            filter(f, onError = () => 'filter: predicate failed') { return predicate(f)(this.value) ? this : runCatch(compose(Either.left, onError), Either.left)(this.value); }
            fold(_, onRight) { return expectedFunctions['core:a-function']('Right.fold:onRight')(onRight)[0](this.value); }
            /**
             * Apply the function wrapped in Right to another Either.
             * Throws TypeError if this.value is not a function (Developer Error).
             */
            ap(v) {
                if (v instanceof Left) return v;
                if (v instanceof Right) return Either.catch(this.value)(v.value);
                else return Either.catch(this.value)(v);
            }
            getOrElse(_) { return this.value; }
            isLeft() { return false; }
            isRight() { return true; }
            tapLeft(_) { return this; }
        }

        // ========== MONOID ==========
        class Monoid {
            constructor(check, concatFn, empty) {
                this.check = check;
                this._concat = concatFn;
                this.empty = empty;
            }
            fold(list, f = identity) {
                const arr = useArrayOrLift(list).map(f);
                if (arr.length === 0) return Either.right(this.empty);
                if (!arr.every(this.check)) {
                    return Either.left(new TypeError('fold: expected an array of values of the same type'));
                }
                return Either.catch(() => arr.reduce(this._concat, this.empty))();
            }
            concat(a, b) {
                if (!this.check(a) || !this.check(b)) {
                    return Either.left(new TypeError('concat: expected values of the same type'));
                }
                return Either.catch(() => this._concat(a, b))();
            }
            power(value, nth) {
                if (!this.check(value)) {
                    return Either.left(new TypeError('power: expected a value of the same type'));
                }
                if (typeof nth !== 'number') {
                    return Either.left(new TypeError('power: expected a number'));
                }
                if (nth < 0) {
                    return Either.left(new TypeError('power: expected a non-negative number'));
                }
                if (nth === 0) return Either.right(this.empty);
                return Either.catch(() => range(nth).reduce(acc => this._concat(acc, value), this.empty))();
            }
            static isMonoid(obj) { return obj instanceof Monoid; }
            static fold(M, f = identity) {
                if (!Monoid.isMonoid(M)) {
                    return () => Either.left(new TypeError('fold: expected a monoid'));
                }
                return list => M.fold(list, f);
            }
            static concat(M) {
                if (!Monoid.isMonoid(M)) {
                    return () => Either.left(new TypeError('concat: expected a monoid'));
                }
                return (a, b) => M.concat(a, b);
            }
            static power(M) {
                if (!Monoid.isMonoid(M)) {
                    return () => Either.left(new TypeError('power: expected a monoid'));
                }
                return (value, nth) => M.power(value, nth);
            }
        }
        class Group extends Monoid {
            constructor(check, concatFn, empty, invertFn) {
                super(check, concatFn, empty);
                this._invert = invertFn;
            }
            invert(value) {
                if (!this.check(value)) {
                    return Either.left(new TypeError('invert: expected a value of the same type'));
                }
                return Either.catch(() => this._invert(value))();
            }
            static isGroup(obj) { return obj instanceof Group; }
            static invert(M) {
                if (!Monoid.isMonoid(M)) {
                    return () => Either.left(new TypeError('invert: expected a monoid'));
                }
                if (!Group.isGroup(M)) {
                    return () => Either.left(new TypeError('invert: expected a monoid with an invert function'));
                }
                return value => M.invert(value);
            }
        }
        const of = {
            number: {
                sum: new Group(a => typeof a === 'number', (a, b) => a + b, 0, a => -a),
                product: new Group(a => typeof a === 'number', (a, b) => a * b, 1, a => 1 / a),
                max: new Monoid(a => typeof a === 'number', (a, b) => Math.max(a, b), -Infinity),
                min: new Monoid(a => typeof a === 'number', (a, b) => Math.min(a, b), Infinity),
            },
            string: {
                concat: new Monoid(a => typeof a === 'string', (a, b) => a + b, ""),
            },
            boolean: {
                any: new Monoid(a => typeof a === 'boolean', (a, b) => a || b, false),
                all: new Monoid(a => typeof a === 'boolean', (a, b) => a && b, true),
                xor: new Group(a => typeof a === 'boolean', (a, b) => a !== b, false, a => a),
            },
            array: {
                concat: new Monoid(a => Array.isArray(a), (a, b) => a.concat(b), []),
            },
            set: {
                union: new Monoid(a => a instanceof Set, (a, b) => new Set([...a, ...b]), new Set()),
            },
            object: {
                merge: new Monoid(isPlainObject, (a, b) => ({ ...a, ...b }), {}),
            },
            function: {
                endo: new Monoid(isFunction, compose2, identity),
            },
            any: {
                first: new Monoid(_ => true, (a, b) => a === null ? b : a, null),
                last: new Monoid(_ => true, (_, b) => b, null),
            },
        };

        // ========== FREE ==========
        const stackSafe = (runner, f, onReentry = f) => {
            let active = false;
            return (...args) => {
                if (active) return onReentry(...args);
                active = true;
                return runCatch(
                    () => {
                        const result = runner(f(...args));
                        if (result instanceof Promise || (result && typeof result.then === 'function')) {
                            return result.finally(() => { active = false; });
                        }
                        active = false;
                        return result;
                    },
                    e => { active = false; throw e; }
                )();
            };
        };
        class Free {
            static of(x) { return new Pure(x); }
            static pure(x) { return new Pure(x); }
            static impure(functor) {
                isFunctor(functor) || raise(new Error(`impure: expected a functor`));
                return new Impure(functor);
            }
            static isPure(x) { return x instanceof Pure; }
            static isImpure(x) { return x instanceof Impure; }
            static liftF(command) {
                isFunctor(command) || raise(new Error(`liftF: expected a functor`));
                return Free.isPure(command) || Free.isImpure(command)
                    ? command
                    : Free.impure(command.map(Free.pure));
            }
            static runSync(runner) {
                return target => {
                    const execute = program => {
                        let step = program;
                        while (Free.isImpure(step)) {
                            step = runner(step.functor);
                            if (Free.isPure(step) && (Free.isPure(step.value) || Free.isImpure(step.value))) {
                                step = step.value;
                            }
                        }
                        return Free.isPure(step) ? step.value : step;
                    };
                    return typeof target === 'function' ? stackSafe(execute, target) : execute(target);
                };
            }
            static runAsync(runner) {
                return target => {
                    const execute = async program => {
                        let step = program;
                        while (Free.isImpure(step)) {
                            step = await runner(step.functor);
                            if (Free.isPure(step) && (Free.isPure(step.value) || Free.isImpure(step.value))) {
                                step = step.value;
                            }
                        }
                        return Free.isPure(step) ? step.value : step;
                    };
                    return typeof target === 'function' ? stackSafe(execute, target) : execute(target);
                };
            }
        }
        class Pure extends Free {
            constructor(value) {
                super();
                this.value = value;
                this[Symbol.toStringTag] = 'Pure';
                this[Types.Functor] = true;
                this[Types.Monad] = true;
            }
            map(f) { return new Pure(f(this.value)); }
            flatMap(f) { return f(this.value); }
        }
        class Impure extends Free {
            constructor(functor) {
                super();
                isFunctor(functor) || raise(new Error(`impure: expected a functor`));
                this.functor = functor;
                this[Symbol.toStringTag] = 'Impure';
                this[Types.Functor] = true;
                this[Types.Monad] = true;
            }
            map(f) { return new Impure(this.functor.map(free => Free.map(f))); }
            flatMap(f) { return new Impure(this.functor.map(free => Free.flatMap(f))); }
        }
        class Thunk {
            constructor(f) {
                this.f = expectedFunctions['core:a-function']('Thunk:f')(f)[0];
                this[Symbol.toStringTag] = 'Thunk';
                this[Types.Functor] = true;
            }
            map(g) { return new Thunk(compose(g, this.f)); }
            run() { return this.f(); }
            static of(f) { return new Thunk(f); }
            static done(value) { return Free.pure(value); }
            static suspend(f) { return Free.liftF(new Thunk(f)); }
        }
        const trampoline = Free.runSync(thunk => thunk.run());

        // ========== EXTRA ==========
        const path = keyStr => data => keyStr.split('.').map(k => k.trim()).reduce(
            (acc, key) => acc.flatMap(obj => Either.fromNullable(obj[key])),
            Either.fromNullable(data)
        );
        const template = (message, data) => message.replace(/\{\{([^}]+)\}\}/g,
            (match, keyStr) => path(keyStr)(data).fold(_ => match, identity));

        // ========== TASK ==========
        expectedFunctions['task:computation-to-be-a-function'] = expectedFunction('a computation function (reject, resolve) => ...');
        expectedFunctions['task:a-function-returning-task'] = expectedFunction('a function returning Task');
        expectedFunctions['a-function-returning-promise'] = expectedFunction('a function returning Promise');
        const normalizeTaskError = e => e instanceof Error ? e : new Error(String(e));
        const toTaskErrorArray = e => useArrayOrLift(e).map(normalizeTaskError);
        const rejectWith = reject => compose(reject, toTaskErrorArray);
        class Task {
            constructor(computation) {
                this.computation = computation;
                this[Symbol.toStringTag] = 'Task';
                this[Types.Functor] = true;
                this[Types.Applicative] = true;
                this[Types.Monad] = true;
            }
            map(f) {
                expectedFunctions['core:a-function']('Task.map:f')(f);
                return new Task((reject, resolve) => {
                    this.computation(reject, runCatch(compose(resolve, f), rejectWith(reject)));
                });
            }
            mapRejected(f) {
                expectedFunctions['core:a-function']('Task.mapRejected:f')(f);
                return new Task((reject, resolve) => {
                    this.computation(compose(reject, errs => errs.map(runCatch(f, identity))), resolve);
                });
            }
            flatMap(f) {
                expectedFunctions['task:a-function-returning-task']('Task.flatMap:f')(f);
                return new Task((reject, resolve) => {
                    this.computation(
                        reject,
                        runCatch(
                            x => {
                                const nextTask = f(x);
                                return nextTask instanceof Task
                                    ? nextTask.computation(reject, resolve)
                                    : reject([new Error('flatMap: function must return a Task')]);
                            },
                            rejectWith(reject)
                        )
                    );
                });
            }
            ap(taskValue) {
                return new Task((reject, resolve) => {
                    let f = null, a = null, fDone = false, aDone = false;
                    let errors = [];
                    const tryResolve = () => {
                        if (fDone && aDone) {
                            errors.length > 0
                                ? reject(errors)
                                : runCatch(() => resolve(f(a)), rejectWith(reject))();
                        }
                    };
                    this.computation(
                        errs => { errors = errors.concat(errs); fDone = true; tryResolve(); },
                        fn => { f = fn; fDone = true; tryResolve(); }
                    );
                    taskValue.computation(
                        errs => { errors = errors.concat(errs); aDone = true; tryResolve(); },
                        x => { a = x; aDone = true; tryResolve(); }
                    );
                });
            }
            fold(onRejected, onResolved) {
                expectedFunctions['core:a-function']('Task.fold:onRejected')(onRejected);
                expectedFunctions['core:a-function']('Task.fold:onResolved')(onResolved);
                return new Task((reject, resolve) => {
                    this.computation(
                        runCatch(compose(resolve, onRejected), rejectWith(reject)),
                        runCatch(compose(resolve, onResolved), rejectWith(reject))
                    );
                });
            }
            run(onRejected, onResolved) {
                expectedFunctions['core:a-function']('Task.run:onRejected')(onRejected);
                expectedFunctions['core:a-function']('Task.run:onResolved')(onResolved);
                this.computation(onRejected, onResolved);
            }
            toPromise() {
                return new Promise((resolve, reject) => {
                    this.computation(errs => reject(new AggregateError(errs, 'Task rejected')), resolve);
                });
            }
            toEither(callback) {
                this.run(compose(callback, Either.left), compose(callback, Either.right));
            }
            static of(x) { return new Task((_, resolve) => resolve(x)); }
            static resolved(x) { return Task.of(x); }
            static rejected(e) { return new Task((reject, _) => reject(toTaskErrorArray(e))); }
            static create(computation) {
                expectedFunctions['task:computation-to-be-a-function']('Task.create:computation')(computation);
                if (computation.length !== 2) {
                    raise(new TypeError(
                        `Task: computation must accept exactly 2 parameters (reject, resolve), but got ${computation.length}`
                    ));
                }
                return new Task(computation);
            }
            static fromPromise(promiseFn) {
                expectedFunctions['a-function-returning-promise']('Task.fromPromise:promiseFn')(promiseFn);
                return (...args) => new Task((reject, resolve) => promiseFn(...args).then(resolve).catch(rejectWith(reject)));
            }
            static fromEither(e) {
                Either.checkEither(e);
                return e.isRight() ? Task.resolved(e.value) : Task.rejected(e.value);
            }
            static all(tasks) { // Promise.allSettled
                return new Task((reject, resolve) => {
                    const list = useArrayOrLift(tasks);
                    if (list.length === 0) return resolve([]);
                    const results = [];
                    const errors = [];
                    let completed = 0;
                    const onComplete = () => {
                        if (completed === list.length) {
                            const flatErrors = errors.flat().filter(Boolean);
                            flatErrors.length > 0 ? reject(flatErrors) : resolve(results);
                        }
                    };
                    list.forEach((t, i) => {
                        t.computation(
                            errs => { errors[i] = errs; completed++; onComplete(); },
                            val => { results[i] = val; completed++; onComplete(); }
                        );
                    });
                });
            }
            static race(tasks) { // TODO: Promise.allSettled
                return new Task((reject, resolve) => {
                    const list = useArrayOrLift(tasks);
                    if (list.length === 0) return reject([new Error('race: empty task list')]);
                    const shared = { called: false };
                    const onceReject = once(reject, { state: shared });
                    const onceResolve = once(resolve, { state: shared });
                    list.forEach(t => t.computation(onceReject, onceResolve));
                });
            }
            static sequence(tasks) {
                const list = useArrayOrLift(tasks);
                return list.reduce(
                    (acc, t) => acc.flatMap(arr => t.map(val => [...arr, val])),
                    Task.resolved([])
                );
            }
            static traverse(f) { return list => Task.sequence(useArrayOrLift(list).map(f)); }
            static pipeK(...fs) {
                expectedFunctions['core:all-arguments-to-be-functions']('Task.pipeK:fs')(...fs);
                if (fs.length === 0) return Task.resolved;
                return (x) => fs.reduce((acc, f) => acc.flatMap(f), Task.resolved(x));
            }
        }
        var instance = {
            core: {
                Types, raise, typeOf, isFunction, isPlainObject, isIterable, toIterator, expectedFunction, expectedFunctions, hasFunctions,
                isFunctor, isApplicative, isMonad, identity, constant, tuple,
                apply, unapply, apply2, unapply2, curry, uncurry, curry2, uncurry2,
                partial, predicate, negate, flip, flip2, flipC, flipCV,
                pipe, pipe2, compose, compose2, once, converge, catch: runCatch, runOrDefault, capture,
                tap, also, into, useOrLift, useArrayOrLift, range, rangeBy, transducer,
            },
            either: {
                Either, left: Either.left, right: Either.right, of: Either.of,
                catch: Either.catch, from: Either.from, fromNullable: Either.fromNullable,
                validate: Either.validate, validateAll: Either.validateAll, sequence: Either.sequence,
                pipeK: Either.pipeK, traverse: Either.traverse, traverseAll: Either.traverseAll,
                checkEither: Either.checkEither,
            },
            monoid: {
                Monoid, Group, ...of, isMonoid: Monoid.isMonoid, isGroup: Group.isGroup,
                fold: Monoid.fold, concat: Monoid.concat, power: Monoid.power, invert: Group.invert,
            },
            free: {
                Free, Thunk,
                of: Free.of, pure: Free.pure, impure: Free.impure,
                isPure: Free.isPure, isImpure: Free.isImpure,
                liftF: Free.liftF, runSync: Free.runSync, runAsync: Free.runAsync,
                done: Thunk.done, suspend: Thunk.suspend, trampoline,
            },
            extra: { path, template },
            task: {
                Task, of: Task.of,
                resolved: Task.resolved, rejected: Task.rejected, create: Task.create,
                fromPromise: Task.fromPromise, fromEither: Task.fromEither,
                all: Task.all, race: Task.race, sequence: Task.sequence, traverse: Task.traverse,
                pipeK: Task.pipeK,
            },
        };
        if (cacheable) cachedInstance = instance;
        return instance;
    };
    return funFpJs;
});

if (typeof module !== 'undefined' && module.exports) {
    module.exports.default = module.exports;
}
