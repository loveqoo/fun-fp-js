/**
 * Fun FP JS - A Lightweight Functional Programming Library
 * UMD (Universal Module Definition) + ESM build
 * 
 * Built: 2025-12-31 12:05:16 (Asia/Seoul)
 * 
 * Supports: CommonJS, AMD, Browser globals, ES Modules
 * 
 * Auto-generated by build.js - DO NOT EDIT DIRECTLY
 * Edit modules/*.js files instead and run: node build.js
 */
(function(root, factory) {
    if (typeof module !== 'undefined' && module.exports) {
        // CommonJS
        module.exports = factory();
        // ESM interop: allow "import funFpJs from '...'" 
        module.exports.default = module.exports;
    } else if (typeof define === 'function' && define.amd) {
        // AMD
        define([], factory);
    } else {
        // Browser globals
        root.funFpJs = factory();
    }
})(typeof self !== 'undefined' ? self : this, function() {
    'use strict';
    var cachedInstance = null;
    var funFpJs = function(dependencies, cacheable) {
        if (cacheable === undefined) cacheable = true;
        if (cacheable && cachedInstance) return cachedInstance;
        dependencies = dependencies || {};

        var log = dependencies.enableLog === false ? function(){} : (typeof dependencies.log === 'function' ? dependencies.log : console.log);

        // ========== CORE ==========
        const Types = { Functor: Symbol.for('fun-fp-js/Functor'), Applicative: Symbol.for('fun-fp-js/Applicative'), Monad: Symbol.for('fun-fp-js/Monad') };
        const raise = e => { throw e; };
        const typeOf = a => {
            switch (typeof a) {
                case 'undefined': return 'undefined';
                case 'boolean': return 'boolean';
                case 'number': return 'number';
                case 'string': return 'string';
                case 'symbol': return 'symbol';
                case 'function': return 'function';
                case 'object': return a === null ? 'null' : ((a.constructor && a.constructor.name) || 'object')
                default: return 'unknown';
            }
        };
        const isFunction = f => typeof f === 'function';
        const isPlainObject = a => typeof a === 'object' && a !== null && !Array.isArray(a) && Object.getPrototypeOf(a) === Object.prototype;
        const isIterable = a => a != null && typeof a[Symbol.iterator] === 'function';
        const toIterator = function* (iterable) {
            if (iterable == null) return;
            if (isIterable(iterable)) {
                yield* iterable;
            } else if (isPlainObject(iterable)) {
                for (const key in iterable) {
                    if (Object.prototype.hasOwnProperty.call(iterable, key)) {
                        yield iterable[key];
                    }
                }
            } else {
                yield iterable;
            }
        };
        const assertFunction = (name, expected) => (...fs) => {
            const invalids = fs.map((f, i) => [i, f]).filter(([_, f]) => !isFunction(f)).map(([i, f]) => `argument ${i} is ${typeOf(f)}`);
            if (invalids.length > 0) raise(new TypeError(`${name}: expected ${expected}, but ${invalids.join(', ')}`));
            return fs; // array
        };

        const assertFunctions = {
            'hasFunction': assertFunction('hasFunction', 'extracts to be functions'),
            'runCatch0': assertFunction('runCatch', 'a function'),
            'runCatch1': assertFunction('runCatch', 'onError to be a function'),
            'apply': assertFunction('apply', 'a function'),
            'apply2': assertFunction('apply2', 'a function'),
            'unapply': assertFunction('unapply', 'a function'),
            'unapply2': assertFunction('unapply2', 'a function'),
            'curry': assertFunction('curry', 'a function'),
            'curry2': assertFunction('curry2', 'a function'),
            'uncurry': assertFunction('uncurry', 'a function'),
            'uncurry2': assertFunction('uncurry2', 'a function'),
            'partial': assertFunction('partial', 'a function'),
            'predicate': assertFunction('predicate', 'a function'),
            'negate': assertFunction('negate', 'a function'),
            'flip': assertFunction('flip', 'a function'),
            'flip2': assertFunction('flip2', 'a function'),
            'flipC': assertFunction('flipC', 'a function'),
            'flipCV': assertFunction('flipCV', 'a function'),
            'pipe': assertFunction('pipe', 'all arguments to be functions'),
            'once': assertFunction('once', 'a function'),
            'converge0': assertFunction('converge', 'a function'),
            'converge1': assertFunction('converge', 'all branch arguments to be functions'),
            'tap': assertFunction('tap', 'all arguments to be functions'),
            'useOrLift0': assertFunction('useOrLift', 'check to be a function'),
            'useOrLift1': assertFunction('useOrLift', 'lift to be a function'),
            'either_fold': assertFunction('Either.fold', 'a function'),
            'either_catch': assertFunction('either.catch', 'a function'),
            'either_validate_condition': assertFunction('either.validate', 'condition to be a function'),
            'either_validate_on_error': assertFunction('either.validate', 'onError to be a function'),
            'either_pipe_k': assertFunction('either.pipeK', 'all arguments to be functions'),
            'either_traverse': assertFunction('either.traverse', 'a function'),
            'either_traverse_all': assertFunction('either.traverseAll', 'a function'),
            'thunk': assertFunction('Thunk', 'a function'),
            'transducer_map': assertFunction('Transducer.map', 'a function'),
            'transducer_filter': assertFunction('Transducer.filter', 'a function'),
            'transducer_flat_map': assertFunction('Transducer.flatMap', 'a function'),
            'task': assertFunction('Task', 'a computation function (reject, resolve) => ...'),
            'task_map': assertFunction('Task.map', 'a function'),
            'task_map_rejected': assertFunction('Task.mapRejected', 'a function'),
            'task_flat_map': assertFunction('Task.flatMap', 'a function returning Task'),
            'task_run': assertFunction('Task.run', 'reject and resolve to be functions'),
            'task_from_promise': assertFunction('Task.fromPromise', 'a function returning Promise'),
            'task_pipe_k': assertFunction('Task.pipeK', 'all arguments to be functions'),
        };
        const hasFunctions = (extracts, check = _ => true) => obj => obj && assertFunctions['hasFunction'](...extracts).every(extract => isFunction(extract(obj))) && check(obj);
        const runCatch = (f, onError = e => log(e)) => {
            assertFunctions['runCatch0'](f);
            assertFunctions['runCatch1'](onError);
            return (...args) => {
                try {
                    return f(...args);
                } catch (e) {
                    return onError(e);
                }
            };
        };
        const isFunctor = hasFunctions([obj => obj.map], obj => obj[Types.Functor]);
        const isApplicative = hasFunctions([obj => obj.map, obj => obj.ap], obj => obj[Types.Functor] && obj[Types.Applicative]);
        const isMonad = hasFunctions([obj => obj.map, obj => obj.flatMap], obj => obj[Types.Functor] && obj[Types.Monad]);
        const identity = x => x;
        const constant = x => () => x;
        const tuple = (...args) => args;
        const apply = f => {
            assertFunctions['apply'](f);
            return args => {
                if (!Array.isArray(args)) {
                    raise(new TypeError(`apply: expected an array of arguments, but got ${typeof args}`));
                }
                return f(...args);
            };
        };
        const apply2 = f => {
            assertFunctions['apply2'](f);
            return args => {
                if (!Array.isArray(args) || args.length !== 2) {
                    raise(new TypeError(`apply2: expected an array of exactly 2 arguments, but got ${Array.isArray(args) ? args.length : typeof args}`));
                }
                return f(args[0], args[1]);
            };
        };
        const unapply = f => {
            assertFunctions['unapply'](f);
            return (...args) => f(args);
        };
        const unapply2 = f => {
            assertFunctions['unapply2'](f);
            return (a, b) => f([a, b]);
        };
        const curry = (f, arity = f.length) => {
            assertFunctions['curry'](f);
            return function _curry(...args) {
                return args.length >= arity ? f(...args) : (...next) => _curry(...args, ...next);
            };
        };
        const curry2 = f => {
            assertFunctions['curry2'](f);
            return a => b => f(a, b);
        };
        const uncurry = f => {
            assertFunctions['uncurry'](f);
            return (...args) => args.reduce((acc, arg, i) => {
                if (!isFunction(acc)) {
                    raise(new TypeError(`uncurry: expected a curried function (function returning functions), but got ${typeof acc} before applying argument ${i}`));
                }
                return acc(arg);
            }, f);
        };
        const uncurry2 = f => {
            assertFunctions['uncurry2'](f);
            return (a, b) => {
                const next = f(a);
                if (!isFunction(next)) {
                    raise(new TypeError(`uncurry2: expected a curried function (function returning a function), but got ${typeof next}`));
                }
                return next(b);
            };
        };
        const partial = (f, ...args) => {
            assertFunctions['partial'](f);
            return (...next) => f(...args, ...next);
        };
        const predicate = (f, fallbackValue = false) => {
            assertFunctions['predicate'](f);
            return (...args) => {
                const result = runCatch(f, _ => fallbackValue)(...args);
                if (result instanceof Promise || (result && typeof result.then === 'function')) {
                    log(new TypeError('predicate: Async functions (Promises) are not supported in sync predicate.'));
                    return Boolean(fallbackValue);
                }
                return Boolean(result);
            };
        };
        const negate = f => {
            assertFunctions['negate'](f);
            return (...args) => !f(...args);
        };
        const flip = f => {
            assertFunctions['flip'](f);
            return (...args) => f(...args.slice().reverse());
        };
        const flip2 = f => {
            assertFunctions['flip2'](f);
            return (a, b, ...args) => f(b, a, ...args);
        };
        const flipC = f => {
            assertFunctions['flipC'](f);
            return a => b => f(b)(a);
        };
        const flipCV = f => {
            assertFunctions['flipCV'](f);
            return (...as) => (...bs) => f(...bs)(...as);
        };
        const pipe = (...fs) => {
            if (fs.length === 0) return identity;
            assertFunctions['pipe'](...fs);
            return x => fs.reduce((acc, f) => f(acc), x);
        };
        const pipe2 = (f, g) => pipe(f, g);
        const compose = (...fs) => pipe(...fs.slice().reverse());
        const compose2 = (f, g) => compose(f, g);
        const once = (f, option = {}) => {
            assertFunctions['once'](f);
            const state = option.state || { called: false };
            const defaultValue = option.defaultValue;
            let result = defaultValue;
            return (...args) => {
                if (!state.called) {
                    const val = f(...args);  // 예외 발생 시 called가 true가 되지 않음
                    result = val;
                    state.called = true;
                }
                return result;
            };
        };
        const converge = (f, ...branches) => {
            assertFunctions['converge0'](f);
            assertFunctions['converge1'](...branches);
            return (...args) => f(...branches.map(branch => branch(...args)));
        };
        const runOrDefault = fallbackValue => g => isFunction(g) ? runCatch(g, _ => fallbackValue)() : fallbackValue;
        const capture = (...args) => (f, onError = e => log(e)) => runCatch(f, onError)(...args);
        const tap = (...fs) => {
            assertFunctions['tap'](...fs);
            return x => {
                const runAgainstX = f => runCatch(f)(x);
                fs.forEach(runAgainstX);
                return x;
            };
        };
        const also = flipCV(tap);
        const into = flipCV(pipe);
        const useOrLift = (check, lift) => {
            assertFunctions['useOrLift0'](check);
            assertFunctions['useOrLift1'](lift);
            return x => predicate(check)(x) ? x : lift(x);
        };
        const useArrayOrLift = useOrLift(Array.isArray, Array.of);
        const range = n => n >= 0 ? Array.from({ length: n }, (_, i) => i) : [];
        const rangeBy = (start, end) => start >= end ? [] : range(end - start).map(i => start + i);

        // ========== EITHER ==========
        const hasConcat = hasFunctions([obj => obj.concat]);
        const normalizeToError = e => e instanceof Error ? e : new Error(typeof e === 'string' ? e : 'Left Error', { cause: e });
        const toEitherErrorArray = e => useArrayOrLift(e).map(normalizeToError);
        class Either {
            static of(x) {
                return new Right(x);
            }
            static right(x) {
                return new Right(x);
            }
            static left(e) {
                return new Left(toEitherErrorArray(e));
            }
            static from(x) {
                if (x instanceof Left || x instanceof Right) return x;
                return Either.right(x);
            }
            static fromNullable(x) {
                if (x === null || x === undefined) {
                    return Either.left(new Error(`fromNullable: expected a value, got ${x}`));
                }
                if (x instanceof Left || x instanceof Right) return x;
                return Either.right(x);
            }
            static catch(f, lift = Either.right) {
                assertFunctions['either_catch'](f);
                return runCatch(compose(lift, f), Either.left);
            }
            static validate(condition, onError) {
                assertFunctions['either_validate_condition'](condition);
                assertFunctions['either_validate_on_error'](onError);
                return x => predicate(condition)(x)
                    ? Either.right(x)
                    : runCatch(compose(Either.left, onError), Either.left)(x);
            }
            static validateAll(list) {
                return useArrayOrLift(list).reduce((acc, x) => {
                    Either.checkEither(x);
                    return Either.right(a => b => [...a, b]).ap(acc).ap(x);
                }, Either.right([]));
            }
            static sequence(list) {
                let acc = [];
                for (const x of useArrayOrLift(list)) {
                    Either.checkEither(x);
                    if (x instanceof Right) {
                        acc.push(x.value);
                    } else {
                        return x;
                    }
                }
                return Either.right(acc);
            }
            static pipeK(...fs) {
                if (fs.length === 0) return Either.from;
                assertFunctions['either_pipe_k'](...fs);
                return (x, lift = Either.from) => fs.reduce((acc, f) => acc.flatMap(f), lift(x));
            }
            static traverse(f) {
                assertFunctions['either_traverse'](f);
                return list => Either.sequence(useArrayOrLift(list).map(f));
            }
            static traverseAll(f) {
                assertFunctions['either_traverse_all'](f);
                return list => Either.validateAll(useArrayOrLift(list).map(f));
            }
            static checkEither(v) {
                return (v instanceof Left || v instanceof Right)
                    ? v
                    : raise(new Error(`checkEither: expected Either, got ${typeof v}`));
            }
        }

        class Left extends Either {
            constructor(value) {
                super();
                this.value = value;
                this[Symbol.toStringTag] = 'Left';
                this[Types.Functor] = true;
                this[Types.Applicative] = true;
                this[Types.Monad] = true;
            }
            map() { return this; }
            mapLeft(f) { return compose(Either.left, runCatch(f, identity))(this.value); }
            flatMap() { return this; }
            filter() { return this; }
            fold(onLeft, _) { return assertFunctions['either_fold'](onLeft)[0](this.value); }
            ap(v) { return (v instanceof Left && hasConcat(this.value) && hasConcat(v.value)) ? Either.left(this.value.concat(v.value)) : this; }
            getOrElse(v) { return v; }
            isLeft() { return true; }
            isRight() { return false; }
            tapLeft(f) { runCatch(f)(this.value); return this; }
        }

        class Right extends Either {
            constructor(value) {
                super();
                this.value = value;
                this[Symbol.toStringTag] = 'Right';
                this[Types.Functor] = true;
                this[Types.Applicative] = true;
                this[Types.Monad] = true;
            }
            map(f) { return Either.catch(f)(this.value); }
            mapLeft() { return this; }
            flatMap(f) { return runCatch(compose(Either.checkEither, f), Either.left)(this.value); }
            filter(f, onError = () => 'filter: predicate failed') { return predicate(f)(this.value) ? this : runCatch(compose(Either.left, onError), Either.left)(this.value); }
            fold(_, onRight) { return assertFunctions['either_fold'](onRight)[0](this.value); }
            /**
             * Apply the function wrapped in Right to another Either.
             * Throws TypeError if this.value is not a function (Developer Error).
             */
            ap(v) {
                if (v instanceof Left) return v;
                if (v instanceof Right) return Either.catch(this.value)(v.value);
                else return Either.catch(this.value)(v);
            }
            getOrElse(_) { return this.value; }
            isLeft() { return false; }
            isRight() { return true; }
            tapLeft(_) { return this; }
        }

        // ========== MONOID ==========
        const monoid = (check, concat, empty) => ({ check, concat, empty });
        const group = (check, concat, empty, invert) => ({ check, concat, empty, invert });
        const of = {
            number: {
                sum: group(a => typeof a === 'number', (a, b) => a + b, 0, a => -a),
                product: group(a => typeof a === 'number', (a, b) => a * b, 1, a => 1 / a),
                max: monoid(a => typeof a === 'number', (a, b) => Math.max(a, b), -Infinity),
                min: monoid(a => typeof a === 'number', (a, b) => Math.min(a, b), Infinity),
            },
            string: {
                concat: monoid(a => typeof a === 'string', (a, b) => a + b, ""),
            },
            boolean: {
                any: monoid(a => typeof a === 'boolean', (a, b) => a || b, false),
                all: monoid(a => typeof a === 'boolean', (a, b) => a && b, true),
                xor: group(a => typeof a === 'boolean', (a, b) => a !== b, false, a => a),
            },
            array: {
                concat: monoid(a => Array.isArray(a), (a, b) => a.concat(b), []),
            },
            set: {
                union: monoid(a => a instanceof Set, (a, b) => new Set([...a, ...b]), new Set()),
            },
            object: {
                merge: monoid(isPlainObject, (a, b) => ({ ...a, ...b }), {}),
            },
            function: {
                endo: monoid(isFunction, compose2, identity),
            },
            any: {
                first: monoid(_ => true, (a, b) => a === null ? b : a, null),
                last: monoid(_ => true, (_, b) => b, null),
            },
        };
        const isMonoid = obj => obj && isFunction(obj.check) && isFunction(obj.concat) && 'empty' in obj;
        const fold = (M, f = identity) => {
            if (!isMonoid(M)) {
                return () => Either.left(new TypeError('fold: expected a monoid'));
            }
            return list => {
                const arr = useArrayOrLift(list).map(f);
                if (arr.length === 0) return Either.right(M.empty);
                if (!arr.every(M.check)) return Either.left(new TypeError('fold: expected an array of values of the same type'));
                return Either.catch(() => arr.reduce(M.concat, M.empty))();
            };
        };
        const concat = M => {
            if (!isMonoid(M)) {
                return () => Either.left(new TypeError('concat: expected a monoid'));
            }
            return (a, b) => {
                if (!M.check(a) || !M.check(b)) {
                    return Either.left(new TypeError('concat: expected values of the same type'));
                }
                return Either.catch(() => M.concat(a, b))();
            };
        };
        const invert = M => {
            if (!isMonoid(M)) {
                return () => Either.left(new TypeError('invert: expected a monoid'));
            }
            if (!('invert' in M)) {
                return () => Either.left(new TypeError('invert: expected a monoid with an invert function'));
            }
            return value => {
                if (!M.check(value)) return Either.left(new TypeError('invert: expected a value of the same type'));
                return Either.catch(() => M.invert(value))();
            };
        };
        const power = M => {
            if (!isMonoid(M)) {
                return () => Either.left(new TypeError('power: expected a monoid'));
            }
            return (value, nth) => {
                if (!M.check(value)) return Either.left(new TypeError('power: expected a value of the same type'));
                if (typeof nth !== 'number') return Either.left(new TypeError('power: expected a number'));
                if (nth < 0) return Either.left(new TypeError('power: expected a non-negative number'));
                if (nth === 0) return Either.right(M.empty);
                return Either.catch(() => range(nth).reduce(acc => M.concat(acc, value), M.empty))();
            };
        };

        // ========== FREE ==========
        const stackSafe = (runner, f, onReentry = f) => {
            let active = false;
            return (...args) => {
                if (active) return onReentry(...args);
                active = true;
                return runCatch(
                    () => {
                        const result = runner(f(...args));
                        if (result instanceof Promise || (result && typeof result.then === 'function')) {
                            return result.finally(() => { active = false; });
                        }
                        active = false;
                        return result;
                    },
                    e => { active = false; throw e; }
                )();
            };
        };
        class Free {
            static of(x) { return new Pure(x); }
            static pure(x) { return new Pure(x); }
            static impure(functor) {
                isFunctor(functor) || raise(new Error(`impure: expected a functor`));
                return new Impure(functor);
            }
            static isPure(x) { return x instanceof Pure; }
            static isImpure(x) { return x instanceof Impure; }
            static liftF(command) {
                isFunctor(command) || raise(new Error(`liftF: expected a functor`));
                return Free.isPure(command) || Free.isImpure(command)
                    ? command
                    : Free.impure(command.map(Free.pure));
            }
            static runSync(runner) {
                return target => {
                    const execute = program => {
                        let step = program;
                        while (Free.isImpure(step)) {
                            step = runner(step.functor);
                            if (Free.isPure(step) && (Free.isPure(step.value) || Free.isImpure(step.value))) {
                                step = step.value;
                            }
                        }
                        return Free.isPure(step) ? step.value : step;
                    };
                    return typeof target === 'function' ? stackSafe(execute, target) : execute(target);
                };
            }
            static runAsync(runner) {
                return target => {
                    const execute = async program => {
                        let step = program;
                        while (Free.isImpure(step)) {
                            step = await runner(step.functor);
                            if (Free.isPure(step) && (Free.isPure(step.value) || Free.isImpure(step.value))) {
                                step = step.value;
                            }
                        }
                        return Free.isPure(step) ? step.value : step;
                    };
                    return typeof target === 'function' ? stackSafe(execute, target) : execute(target);
                };
            }
        }
        class Pure extends Free {
            constructor(value) {
                super();
                this.value = value;
                this[Symbol.toStringTag] = 'Pure';
                this[Types.Functor] = true;
                this[Types.Monad] = true;
            }
            map(f) { return new Pure(f(this.value)); }
            flatMap(f) { return f(this.value); }
        }
        class Impure extends Free {
            constructor(functor) {
                super();
                isFunctor(functor) || raise(new Error(`impure: expected a functor`));
                this.functor = functor;
                this[Symbol.toStringTag] = 'Impure';
                this[Types.Functor] = true;
                this[Types.Monad] = true;
            }
            map(f) { return new Impure(this.functor.map(free => Free.map(f))); }
            flatMap(f) { return new Impure(this.functor.map(free => Free.flatMap(f))); }
        }
        class Thunk {
            constructor(f) {
                this.f = assertFunctions['thunk'](f)[0];
                this[Symbol.toStringTag] = 'Thunk';
                this[Types.Functor] = true;
            }
            map(g) { return new Thunk(compose(g, this.f)); }
            run() { return this.f(); }
            static of(f) { return new Thunk(f); }
            static done(value) { return Free.pure(value); }
            static suspend(f) { return Free.liftF(new Thunk(f)); }
        }
        const trampoline = Free.runSync(thunk => thunk.run());

        // ========== TRANSDUCER ==========

        class Reduced {
            constructor(value) {
                this.value = value;
            }
        }

        class Transducer {
            constructor(source, transformers = []) {
                if (!isIterable(source)) {
                    raise(new TypeError('Transducer: source must be an iterable'));
                }
                this.source = source;
                this.transformers = transformers;
                this[Types.Functor] = true;
                this[Types.Monad] = true;
            }

            static reduced(value) {
                return new Reduced(value);
            }

            static isReduced(value) {
                return value instanceof Reduced;
            }

            append(transformer) {
                return new Transducer(this.source, [...this.transformers, transformer]);
            }

            map(f) {
                assertFunctions['transducer_map'](f);
                const transformer = step => (acc, val) => step(acc, f(val));
                return this.append(transformer);
            }

            flatMap(f) {
                assertFunctions['transducer_flat_map'](f);
                const transformer = step => (acc, val) => {
                    let result = acc;
                    for (const inner of toIterator(f(val))) {
                        result = step(result, inner);
                        if (Transducer.isReduced(result)) return result;
                    }
                    return result;
                };
                return this.append(transformer);
            }

            filter(predicate) {
                assertFunctions['transducer_filter'](predicate);
                const transformer = step => (acc, val) => predicate(val) ? step(acc, val) : acc;
                return this.append(transformer);
            }

            take(count) {
                let taken = 0;
                const transformer = step => (acc, val) => {
                    if (taken >= count) return Transducer.reduced(acc);
                    taken++;
                    const next = step(acc, val);
                    if (Transducer.isReduced(next)) return next;
                    return taken >= count ? Transducer.reduced(next) : next;
                };
                return this.append(transformer);
            }

            drop(count) {
                let dropped = 0;
                const transformer = step => (acc, val) => {
                    if (dropped < count) { dropped++; return acc; }
                    return step(acc, val);
                };
                return this.append(transformer);
            }

            reduce(reducer, initial) {
                const composed = compose(...this.transformers);
                const step = composed(reducer);
                let acc = initial;
                for (const val of toIterator(this.source)) {
                    acc = step(acc, val);
                    if (Transducer.isReduced(acc)) { acc = acc.value; break; }
                }
                return acc;
            }

            collect() {
                return this.reduce((arr, val) => { arr.push(val); return arr; }, []);
            }

            fold(M, f = identity) {
                return fold(M, f)(this.collect());
            }

            sum() {
                return this.reduce((total, val) => total + val, 0);
            }

            join(separator = '') {
                const result = this.reduce(
                    (str, val) => str === null ? String(val) : str + separator + val,
                    null
                );
                return result ?? '';
            }

            count() {
                return this.reduce(n => n + 1, 0);
            }

            first() {
                return this.take(1).reduce((_, val) => val, undefined);
            }

            forEach(f) {
                this.reduce((_, val) => { f(val); }, undefined);
            }
        }

        const from = source => new Transducer(source);

        // ========== EXTRA ==========
        const path = keyStr => data => keyStr.split('.').map(k => k.trim()).reduce(
            (acc, key) => acc.flatMap(obj => Either.fromNullable(obj[key])),
            Either.fromNullable(data)
        );
        const template = (message, data) => message.replace(/\{\{([^}]+)\}\}/g,
            (match, keyStr) => path(keyStr)(data).fold(_ => match, identity));

        // ========== TASK ==========
        const normalizeTaskError = e => e instanceof Error ? e : new Error(String(e));
        const toTaskErrorArray = e => useArrayOrLift(e).map(normalizeTaskError);
        const rejectWith = reject => compose(reject, toTaskErrorArray);
        class Task {
            constructor(computation) {
                this.computation = computation;
                this[Symbol.toStringTag] = 'Task';
                this[Types.Functor] = true;
                this[Types.Applicative] = true;
                this[Types.Monad] = true;
            }
            map(f) {
                assertFunctions['task_map'](f);
                return new Task((reject, resolve) => {
                    this.computation(
                        reject,
                        runCatch(compose(resolve, f), rejectWith(reject))
                    );
                });
            }
            mapRejected(f) {
                assertFunctions['task_map_rejected'](f);
                return new Task((reject, resolve) => {
                    this.computation(
                        compose(reject, errs => errs.map(runCatch(f, identity))),
                        resolve
                    );
                });
            }
            flatMap(f) {
                assertFunctions['task_flat_map'](f);
                return new Task((reject, resolve) => {
                    this.computation(
                        reject,
                        runCatch(
                            x => {
                                const nextTask = f(x);
                                return nextTask instanceof Task
                                    ? nextTask.computation(reject, resolve)
                                    : reject([new Error('flatMap: function must return a Task')]);
                            },
                            rejectWith(reject)
                        )
                    );
                });
            }
            ap(taskValue) {
                return new Task((reject, resolve) => {
                    let f = null, a = null, fDone = false, aDone = false;
                    let errors = [];

                    const tryResolve = () => {
                        if (fDone && aDone) {
                            errors.length > 0
                                ? reject(errors)
                                : runCatch(() => resolve(f(a)), rejectWith(reject))();
                        }
                    };

                    this.computation(
                        errs => { errors = errors.concat(errs); fDone = true; tryResolve(); },
                        fn => { f = fn; fDone = true; tryResolve(); }
                    );

                    taskValue.computation(
                        errs => { errors = errors.concat(errs); aDone = true; tryResolve(); },
                        x => { a = x; aDone = true; tryResolve(); }
                    );
                });
            }
            fold(onRejected, onResolved) {
                return new Task((reject, resolve) => {
                    this.computation(
                        runCatch(compose(resolve, onRejected), rejectWith(reject)),
                        runCatch(compose(resolve, onResolved), rejectWith(reject))
                    );
                });
            }
            run(onRejected, onResolved) {
                assertFunctions['task_run'](onRejected);
                assertFunctions['task_run'](onResolved);
                this.computation(onRejected, onResolved);
            }
            toPromise() {
                return new Promise((resolve, reject) => {
                    this.computation(
                        errs => reject(new AggregateError(errs, 'Task rejected')),
                        resolve
                    );
                });
            }
            toEither(callback) {
                this.run(
                    compose(callback, Either.left),
                    compose(callback, Either.right)
                );
            }
            static of(x) { return new Task((_, resolve) => resolve(x)); }
            static resolved(x) { return Task.of(x); }
            static rejected(e) { return new Task((reject, _) => reject(toTaskErrorArray(e))); }
            static create(computation) {
                assertFunctions['task'](computation);
                if (computation.length !== 2) {
                    raise(new TypeError(
                        `Task: computation must accept exactly 2 parameters (reject, resolve), but got ${computation.length}`
                    ));
                }
                return new Task(computation);
            }
            static fromPromise(promiseFn) {
                assertFunctions['task_from_promise'](promiseFn);
                return (...args) => new Task((reject, resolve) => {
                    promiseFn(...args)
                        .then(resolve)
                        .catch(rejectWith(reject));
                });
            }
            static fromEither(e) {
                Either.checkEither(e);
                return e.isRight() ? Task.resolved(e.value) : Task.rejected(e.value);
            }
            static all(tasks) {
                return new Task((reject, resolve) => {
                    const list = useArrayOrLift(tasks);
                    if (list.length === 0) return resolve([]);

                    const results = [];
                    const errors = [];
                    let completed = 0;

                    const onComplete = () => {
                        if (completed === list.length) {
                            const flatErrors = errors.flat().filter(Boolean);
                            flatErrors.length > 0 ? reject(flatErrors) : resolve(results);
                        }
                    };

                    list.forEach((t, i) => {
                        t.computation(
                            errs => { errors[i] = errs; completed++; onComplete(); },
                            val => { results[i] = val; completed++; onComplete(); }
                        );
                    });
                });
            }
            static race(tasks) {
                return new Task((reject, resolve) => {
                    const list = useArrayOrLift(tasks);
                    if (list.length === 0) return reject([new Error('race: empty task list')]);

                    const shared = { called: false };
                    const onceReject = once(reject, { state: shared });
                    const onceResolve = once(resolve, { state: shared });

                    list.forEach(t => t.computation(onceReject, onceResolve));
                });
            }
            static sequence(tasks) {
                const list = useArrayOrLift(tasks);
                return list.reduce(
                    (acc, t) => acc.flatMap(arr => t.map(val => [...arr, val])),
                    Task.resolved([])
                );
            }
            static traverse(f) { return list => Task.sequence(useArrayOrLift(list).map(f)); }
            static pipeK(...fs) {
                fs.forEach(f => assertFunctions['task_pipe_k'](f));
                if (fs.length === 0) return Task.resolved;
                return (x) => fs.reduce((acc, f) => acc.flatMap(f), Task.resolved(x));
            }
        }
        var instance = {
            core: {
                Types, raise, typeOf, isFunction, isPlainObject, isIterable, toIterator, assertFunction, hasFunctions,
                isFunctor, isApplicative, isMonad, identity, constant, tuple,
                apply, unapply, apply2, unapply2, curry, uncurry, curry2, uncurry2,
                partial, predicate, negate, flip, flip2, flipC, flipCV,
                pipe, pipe2, compose, compose2, once, converge, catch: runCatch, runOrDefault, capture,
                tap, also, into, useOrLift, useArrayOrLift, range, rangeBy,
            },
            either: {
                Either,
                left: Either.left,
                right: Either.right,
                of: Either.of,
                catch: Either.catch,
                from: Either.from,
                fromNullable: Either.fromNullable,
                validate: Either.validate,
                validateAll: Either.validateAll,
                sequence: Either.sequence,
                pipeK: Either.pipeK,
                traverse: Either.traverse,
                traverseAll: Either.traverseAll,
                checkEither: Either.checkEither,
            },
            monoid: {
                ...of, isMonoid, fold, concat, invert, power,
            },
            free: {
                Free,
                Thunk,
                of: Free.of,
                pure: Free.pure,
                impure: Free.impure,
                isPure: Free.isPure,
                isImpure: Free.isImpure,
                liftF: Free.liftF,
                runSync: Free.runSync,
                runAsync: Free.runAsync,
                done: Thunk.done,
                suspend: Thunk.suspend,
                trampoline,
            },
            transducer: {
                from,
                Transducer,
            },
            extra: {
                path,
                template,
            },
            task: {
                Task,
                of: Task.of,
                resolved: Task.resolved,
                rejected: Task.rejected,
                create: Task.create,
                fromPromise: Task.fromPromise,
                fromEither: Task.fromEither,
                all: Task.all,
                race: Task.race,
                sequence: Task.sequence,
                traverse: Task.traverse,
                pipeK: Task.pipeK,
            },
        };
        if (cacheable) cachedInstance = instance;
        return instance;
    };
    return funFpJs;
});

// ESM interop: allow default import in ES Modules
// Usage: import funFpJs from './all_in_one.cjs';
if (typeof module !== 'undefined' && module.exports) {
    module.exports.default = module.exports;
}
