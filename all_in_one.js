/**
 * Fun FP JS - A Lightweight Functional Programming Library
 * UMD (Universal Module Definition) build
 * 
 * Built: 2025-12-29 00:12:50 (Asia/Seoul)
 * 
 * Auto-generated by build.js - DO NOT EDIT DIRECTLY
 * Edit modules/*.js files instead and run: node build.js
 */
(function(root, factory) {
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = factory();
    } else if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else {
        root.funFpJs = factory();
    }
})(typeof self !== 'undefined' ? self : this, function() {
    'use strict';
    var funFpJs = function(dependencies) {
        dependencies = dependencies || {};
        var log = dependencies.enableLog === false ? function(){} : (typeof dependencies.log === 'function' ? dependencies.log : console.log);

        // ========== CORE ==========
        const Types = { Functor: Symbol.for('fun-fp-js/Functor'), Applicative: Symbol.for('fun-fp-js/Applicative'), Monad: Symbol.for('fun-fp-js/Monad') };
        const raise = e => { throw e; };
        const typeOf = a => {
            switch (typeof a) {
                case 'undefined': return 'undefined';
                case 'boolean': return 'boolean';
                case 'number': return 'number';
                case 'string': return 'string';
                case 'symbol': return 'symbol';
                case 'function': return 'function';
                case 'object': return a === null ? 'null' : ((a.constructor && a.constructor.name) || 'object')
                default: return 'unknown';
            }
        };
        const isFunction = f => typeof f === 'function';
        const isPlainObject = a => typeof a === 'object' && a !== null && !Array.isArray(a) && Object.getPrototypeOf(a) === Object.prototype;
        const assertFunction = (name, expected) => (...fs) => {
            const invalids = fs.map((f, i) => [i, f]).filter(([_, f]) => !isFunction(f)).map(([i, f]) => `argument ${i} is ${typeOf(f)}`);
            if (invalids.length > 0) raise(new TypeError(`${name}: expected ${expected}, but ${invalids.join(', ')}`));
            return fs; // array
        };

        const assertFunctions = {
            'hasFunction': assertFunction('hasFunction', 'extracts to be functions'),
            'runCatch0': assertFunction('runCatch', 'a function'),
            'runCatch1': assertFunction('runCatch', 'onError to be a function'),
            'apply': assertFunction('apply', 'a function'),
            'apply2': assertFunction('apply2', 'a function'),
            'unapply': assertFunction('unapply', 'a function'),
            'unapply2': assertFunction('unapply2', 'a function'),
            'curry': assertFunction('curry', 'a function'),
            'curry2': assertFunction('curry2', 'a function'),
            'uncurry': assertFunction('uncurry', 'a function'),
            'uncurry2': assertFunction('uncurry2', 'a function'),
            'partial': assertFunction('partial', 'a function'),
            'predicate': assertFunction('predicate', 'a function'),
            'negate': assertFunction('negate', 'a function'),
            'flip': assertFunction('flip', 'a function'),
            'flip2': assertFunction('flip2', 'a function'),
            'flipC': assertFunction('flipC', 'a function'),
            'pipe': assertFunction('pipe', 'all arguments to be functions'),
            'once': assertFunction('once', 'a function'),
            'converge0': assertFunction('converge', 'a function'),
            'converge1': assertFunction('converge', 'all branch arguments to be functions'),
            'tap': assertFunction('tap', 'all arguments to be functions'),
            'useOrLift0': assertFunction('useOrLift', 'check to be a function'),
            'useOrLift1': assertFunction('useOrLift', 'lift to be a function'),
            'either_fold': assertFunction('Either.fold', 'a function'),
            'either_catch': assertFunction('either.catch', 'a function'),
            'either_validate_condition': assertFunction('either.validate', 'condition to be a function'),
            'either_validate_on_error': assertFunction('either.validate', 'onError to be a function'),
            'either_pipe_k': assertFunction('either.pipeK', 'all arguments to be functions'),
            'either_traverse': assertFunction('either.traverse', 'a function'),
            'either_traverse_all': assertFunction('either.traverseAll', 'a function'),
            'thunk': assertFunction('Thunk', 'a function'),
            'task': assertFunction('Task', 'a computation function (reject, resolve) => ...'),
            'task_map': assertFunction('Task.map', 'a function'),
            'task_flat_map': assertFunction('Task.flatMap', 'a function returning Task'),
            'task_run': assertFunction('Task.run', 'reject and resolve to be functions'),
        };
        const hasFunctions = (extracts, check = _ => true) => obj => obj && assertFunctions['hasFunction'](...extracts).every(extract => isFunction(extract(obj))) && check(obj);
        const runCatch = (f, onError = e => log(e)) => {
            assertFunctions['runCatch0'](f);
            assertFunctions['runCatch1'](onError);
            return (...args) => {
                try {
                    return f(...args);
                } catch (e) {
                    return onError(e);
                }
            };
        };
        const isFunctor = hasFunctions([obj => obj.map], obj => obj[Types.Functor]);
        const isApplicative = hasFunctions([obj => obj.map, obj => obj.ap], obj => obj[Types.Functor] && obj[Types.Applicative]);
        const isMonad = hasFunctions([obj => obj.map, obj => obj.flatMap], obj => obj[Types.Functor] && obj[Types.Monad]);
        const identity = x => x;
        const constant = x => () => x;
        const tuple = (...args) => args;
        const apply = f => {
            assertFunctions['apply'](f);
            return args => {
                if (!Array.isArray(args)) {
                    raise(new TypeError(`apply: expected an array of arguments, but got ${typeof args}`));
                }
                return f(...args);
            };
        };
        const apply2 = f => {
            assertFunctions['apply2'](f);
            return args => {
                if (!Array.isArray(args) || args.length !== 2) {
                    raise(new TypeError(`apply2: expected an array of exactly 2 arguments, but got ${Array.isArray(args) ? args.length : typeof args}`));
                }
                return f(args[0], args[1]);
            };
        };
        const unapply = f => {
            assertFunctions['unapply'](f);
            return (...args) => f(args);
        };
        const unapply2 = f => {
            assertFunctions['unapply2'](f);
            return (a, b) => f([a, b]);
        };
        const curry = (f, arity = f.length) => {
            assertFunctions['curry'](f);
            return function _curry(...args) {
                return args.length >= arity ? f(...args) : (...next) => _curry(...args, ...next);
            };
        };
        const curry2 = f => {
            assertFunctions['curry2'](f);
            return a => b => f(a, b);
        };
        const uncurry = f => {
            assertFunctions['uncurry'](f);
            return (...args) => args.reduce((acc, arg, i) => {
                if (!isFunction(acc)) {
                    raise(new TypeError(`uncurry: expected a curried function (function returning functions), but got ${typeof acc} before applying argument ${i}`));
                }
                return acc(arg);
            }, f);
        };
        const uncurry2 = f => {
            assertFunctions['uncurry2'](f);
            return (a, b) => {
                const next = f(a);
                if (!isFunction(next)) {
                    raise(new TypeError(`uncurry2: expected a curried function (function returning a function), but got ${typeof next}`));
                }
                return next(b);
            };
        };
        const partial = (f, ...args) => {
            assertFunctions['partial'](f);
            return (...next) => f(...args, ...next);
        };
        const predicate = (f, fallbackValue = false) => {
            assertFunctions['predicate'](f);
            return (...args) => {
                const result = runCatch(f, _ => fallbackValue)(...args);
                if (result instanceof Promise || (result && typeof result.then === 'function')) {
                    log(new TypeError('predicate: Async functions (Promises) are not supported in sync predicate.'));
                    return Boolean(fallbackValue);
                }
                return Boolean(result);
            };
        };
        const negate = f => {
            assertFunctions['negate'](f);
            return (...args) => !f(...args);
        };
        const flip = f => {
            assertFunctions['flip'](f);
            return (...args) => f(...args.slice().reverse());
        };
        const flip2 = f => {
            assertFunctions['flip2'](f);
            return (a, b, ...args) => f(b, a, ...args);
        };
        const flipC = f => {
            assertFunctions['flipC'](f);
            return a => b => f(b)(a);
        };
        const pipe = (...fs) => {
            if (fs.length === 0) return identity;
            assertFunctions['pipe'](...fs);
            return x => fs.reduce((acc, f) => f(acc), x);
        };
        const pipe2 = (f, g) => pipe(f, g);
        const compose = (...fs) => pipe(...fs.slice().reverse());
        const compose2 = (f, g) => compose(f, g);
        const once = (f, option = {}) => {
            assertFunctions['once'](f);
            const state = option.state || { called: false };
            const defaultValue = option.defaultValue;
            let result = defaultValue;
            return (...args) => {
                if (!state.called) {
                    const val = f(...args);  // 예외 발생 시 called가 true가 되지 않음
                    result = val;
                    state.called = true;
                }
                return result;
            };
        };
        const converge = (f, ...branches) => {
            assertFunctions['converge0'](f);
            assertFunctions['converge1'](...branches);
            return (...args) => f(...branches.map(branch => branch(...args)));
        };
        const runOrDefault = fallbackValue => g => isFunction(g) ? runCatch(g, _ => fallbackValue)() : fallbackValue;
        const capture = (...args) => (f, onError = e => log(e)) => runCatch(f, onError)(...args);
        const tap = (...fs) => {
            assertFunctions['tap'](...fs);
            return x => {
                const runAgainstX = f => runCatch(f)(x);
                fs.forEach(runAgainstX);
                return x;
            };
        };
        const also = x => (...fs) => tap(...fs)(x);
        const into = x => (...fs) => pipe(...fs)(x);
        const useOrLift = (check, lift) => {
            assertFunctions['useOrLift0'](check);
            assertFunctions['useOrLift1'](lift);
            return x => predicate(check)(x) ? x : lift(x);
        };
        const useArrayOrLift = useOrLift(Array.isArray, Array.of);
        const range = n => n >= 0 ? Array.from({ length: n }, (_, i) => i) : [];
        const rangeBy = (start, end) => start >= end ? [] : range(end - start).map(i => start + i);

        // ========== EITHER ==========
        class Left {
            constructor(value) {
                this.value = value;
                this[Symbol.toStringTag] = 'Left';
                this[Types.Functor] = true;
                this[Types.Applicative] = true;
                this[Types.Monad] = true;
            }
            map() { return this; }
            mapLeft(f) { return compose(left, runCatch(f, identity))(this.value); }
            flatMap() { return this; }
            filter() { return this; }
            fold(onLeft, _) { return assertFunctions['either_fold'](onLeft)[0](this.value); }
            ap(v) { return (v instanceof Left && hasConcat(this.value) && hasConcat(v.value)) ? left(this.value.concat(v.value)) : this; }
            getOrElse(v) { return v; }
            isLeft() { return true; }
            isRight() { return false; }
            tapLeft(f) { runCatch(f)(this.value); return this; }
        }
        class Right {
            constructor(value) {
                this.value = value;
                this[Symbol.toStringTag] = 'Right';
                this[Types.Functor] = true;
                this[Types.Applicative] = true;
                this[Types.Monad] = true;
            }
            map(f) { return eitherCatch(f)(this.value); }
            mapLeft() { return this; }
            flatMap(f) { return runCatch(compose(checkEither, f), left)(this.value); }
            filter(f, onError = () => 'filter: predicate failed') { return predicate(f)(this.value) ? this : runCatch(compose(left, onError), left)(this.value); }
            fold(_, onRight) { return assertFunctions['either_fold'](onRight)[0](this.value); }
            /**
             * Apply the function wrapped in Right to another Either.
             * Throws TypeError if this.value is not a function (Developer Error).
             */
            ap(v) {
                if (v instanceof Left) return v;
                if (v instanceof Right) return eitherCatch(this.value)(v.value);
                else return eitherCatch(this.value)(v);
            }
            getOrElse(_) { return this.value; }
            isLeft() { return false; }
            isRight() { return true; }
            tapLeft(_) { return this; }
        }
        const hasConcat = hasFunctions([obj => obj.concat]);
        const checkEither = v => (v instanceof Left || v instanceof Right)
            ? v : raise(new Error(`checkEither: expected Either, got ${typeof v}`));
        const left = e => new Left(useArrayOrLift(e).map(v =>
            v instanceof Error ? v : new Error(typeof v === 'string' ? v : 'Left Error', { cause: v })
        ));
        const right = x => new Right(x);
        const eitherCatch = (f, lift = right) => runCatch(compose(lift, assertFunctions['either_catch'](f)[0]), left);
        const _from = (checkNull, name = 'from') => x => {
            if (checkNull && (x === null || x === undefined)) return left(new Error(`${name}: expected a value, got ${x}`));
            if (x instanceof Left || x instanceof Right) return x;
            return right(x);
        };
        const from = _from(false);
        const fromNullable = _from(true, 'fromNullable');
        const validate = (condition, onError) => {
            assertFunctions['either_validate_condition'](condition);
            assertFunctions['either_validate_on_error'](onError);
            return x => predicate(condition)(x) ? right(x) : runCatch(compose(left, onError), left)(x);
        };
        const validateAll = list => useArrayOrLift(list).reduce((acc, x) => {
            if (x instanceof Left || x instanceof Right) {
                return right(a => b => [...a, b]).ap(acc).ap(x);
            }
            return raise(new Error(`validateAll: expected Either, got ${typeof x}`));
        }, right([]));
        const sequence = list => {
            let acc = [];
            for (const x of useArrayOrLift(list)) {
                if (x instanceof Right) {
                    acc.push(x.value);
                } else if (x instanceof Left) {
                    return x;
                } else {
                    return raise(new Error(`sequence: expected Either, got ${typeof x}`));
                }
            }
            return right(acc);
        };
        const pipeK = (...fs) => {
            if (fs.length === 0) return from;
            assertFunctions['either_pipe_k'](...fs);
            return (x, lift = from) => fs.reduce((acc, f) => acc.flatMap(f), lift(x));
        };
        const traverse = f => {
            assertFunctions['either_traverse'](f);
            return list => sequence(useArrayOrLift(list).map(f));
        };
        const traverseAll = f => {
            assertFunctions['either_traverse_all'](f);
            return list => validateAll(useArrayOrLift(list).map(f));
        };

        // ========== MONOID ==========
        const monoid = (check, concat, empty) => ({ check, concat, empty });
        const group = (check, concat, empty, invert) => ({ check, concat, empty, invert });
        const of = {
            number: {
                sum: group(a => typeof a === 'number', (a, b) => a + b, 0, a => -a),
                product: group(a => typeof a === 'number', (a, b) => a * b, 1, a => 1 / a),
                max: monoid(a => typeof a === 'number', (a, b) => Math.max(a, b), -Infinity),
                min: monoid(a => typeof a === 'number', (a, b) => Math.min(a, b), Infinity),
            },
            string: {
                concat: monoid(a => typeof a === 'string', (a, b) => a + b, ""),
            },
            boolean: {
                any: monoid(a => typeof a === 'boolean', (a, b) => a || b, false),
                all: monoid(a => typeof a === 'boolean', (a, b) => a && b, true),
                xor: group(a => typeof a === 'boolean', (a, b) => a !== b, false, a => a),
            },
            array: {
                concat: monoid(a => Array.isArray(a), (a, b) => a.concat(b), []),
            },
            object: {
                merge: monoid(isPlainObject, (a, b) => ({ ...a, ...b }), {}),
            },
            function: {
                endo: monoid(isFunction, compose2, identity),
            },
            any: {
                first: monoid(_ => true, (a, b) => a === null ? b : a, null),
                last: monoid(_ => true, (_, b) => b, null),
            },
        };
        const isMonoid = obj => obj && isFunction(obj.check) && isFunction(obj.concat) && 'empty' in obj;
        const fold = (M, f = identity) => {
            if (!isMonoid(M)) {
                return () => left(new TypeError('fold: expected a monoid'));
            }
            return list => {
                const arr = useArrayOrLift(list).map(f);
                if (arr.length === 0) return right(M.empty);
                if (!arr.every(M.check)) return left(new TypeError('fold: expected an array of values of the same type'));
                return eitherCatch(() => arr.reduce(M.concat, M.empty))();
            };
        };
        const concat = M => {
            if (!isMonoid(M)) {
                return () => left(new TypeError('concat: expected a monoid'));
            }
            return (a, b) => {
                if (!M.check(a) || !M.check(b)) {
                    return left(new TypeError('concat: expected values of the same type'));
                }
                return eitherCatch(() => M.concat(a, b))();
            };
        };
        const invert = M => {
            if (!isMonoid(M)) {
                return () => left(new TypeError('invert: expected a monoid'));
            }
            if (!('invert' in M)) {
                return () => left(new TypeError('invert: expected a monoid with an invert function'));
            }
            return value => {
                if (!M.check(value)) return left(new TypeError('invert: expected a value of the same type'));
                return eitherCatch(() => M.invert(value))();
            };
        };
        const power = M => {
            if (!isMonoid(M)) {
                return () => left(new TypeError('power: expected a monoid'));
            }
            return (value, nth) => {
                if (!M.check(value)) return left(new TypeError('power: expected a value of the same type'));
                if (typeof nth !== 'number') return left(new TypeError('power: expected a number'));
                if (nth < 0) return left(new TypeError('power: expected a non-negative number'));
                if (nth === 0) return right(M.empty);
                return eitherCatch(() => range(nth).reduce(acc => M.concat(acc, value), M.empty))();
            };
        };

        // ========== FREE ==========
        class Pure {
            constructor(value) {
                this.value = value;
                this[Symbol.toStringTag] = 'Pure';
                this[Types.Functor] = true;
                this[Types.Monad] = true;
            }
            map(f) { return new Pure(f(this.value)); }
            flatMap(f) { return f(this.value); }
        }
        class Impure {
            constructor(functor) {
                isFunctor(functor) || raise(new Error(`impure: expected a functor`));
                this.functor = functor;
                this[Symbol.toStringTag] = 'Impure';
                this[Types.Functor] = true;
                this[Types.Monad] = true;
            }
            map(f) { return new Impure(this.functor.map(free => free.map(f))); }
            flatMap(f) { return new Impure(this.functor.map(free => free.flatMap(f))); }
        }
        const pure = x => new Pure(x);
        const impure = functor => new Impure(functor);
        const isPure = x => x instanceof Pure;
        const isImpure = x => x instanceof Impure;
        const liftF = command => {
            isFunctor(command) || raise(new Error(`liftF: expected a functor`));
            return isPure(command) || isImpure(command) ? command : impure(command.map(pure));
        };
        const stackSafe = (runner, f, onReentry = f) => {
            let active = false;
            return (...args) => {
                if (active) return onReentry(...args);
                active = true;
                try {
                    const result = runner(f(...args));
                    // Handle Async Promise (for runAsync)
                    if (result instanceof Promise || (result && typeof result.then === 'function')) {
                        return result.finally(() => { active = false; });
                    }
                    active = false;
                    return result;
                } catch (e) {
                    active = false;
                    throw e;
                }
            };
        };
        const runSync = runner => target => {
            const execute = program => {
                let step = program;
                while (isImpure(step)) {
                    step = runner(step.functor);
                    if (isPure(step) && (isPure(step.value) || isImpure(step.value))) step = step.value;
                }
                return isPure(step) ? step.value : step;
            };
            return typeof target === 'function' ? stackSafe(execute, target) : execute(target);
        };
        const runAsync = runner => target => {
            const execute = async program => {
                let step = program;
                while (isImpure(step)) {
                    step = await runner(step.functor);
                    if (isPure(step) && (isPure(step.value) || isImpure(step.value))) step = step.value;
                }
                return isPure(step) ? step.value : step;
            };
            return typeof target === 'function' ? stackSafe(execute, target) : execute(target);
        };
        class Thunk {
            constructor(f) {
                this.f = assertFunctions['thunk'](f)[0];
                this[Symbol.toStringTag] = 'Thunk';
                this[Types.Functor] = true;
            }
            map(g) { return new Thunk(compose(g, this.f)); }
            run() { return this.f(); }
        }
        const done = value => pure(value);
        const suspend = f => liftF(new Thunk(f));
        const trampoline = runSync(thunk => thunk.run());

        // ========== EXTRA ==========
        // path('user.address.city')(obj) => Either - 문자열 경로로 중첩 속성 접근
        const path = keyStr => data => keyStr.split('.').map(k => k.trim()).reduce(
            (acc, key) => acc.flatMap(obj => fromNullable(obj[key])),
            fromNullable(data)
        );

        // template: path를 재사용
        const template = (message, data) => message.replace(/\{\{([^}]+)\}\}/g,
            (match, keyStr) => path(keyStr)(data).fold(_ => match, identity));

        // ========== TASK ==========

        // Error normalization helper
        const normalizeError = e => e instanceof Error ? e : new Error(String(e));
        const toErrorArray = e => useArrayOrLift(e).map(normalizeError);
        const rejectWith = reject => compose(reject, toErrorArray);

        class Task {
            constructor(computation) {
                this.computation = computation;
                this[Symbol.toStringTag] = 'Task';
                this[Types.Functor] = true;
                this[Types.Applicative] = true;
                this[Types.Monad] = true;
            }

            map(f) {
                assertFunctions['task_map'](f);
                return new Task((reject, resolve) => {
                    this.computation(
                        reject,
                        runCatch(compose(resolve, f), rejectWith(reject))
                    );
                });
            }

            mapRejected(f) {
                return new Task((reject, resolve) => {
                    this.computation(
                        compose(reject, errs => errs.map(runCatch(f, identity))),
                        resolve
                    );
                });
            }

            flatMap(f) {
                assertFunctions['task_flat_map'](f);
                return new Task((reject, resolve) => {
                    this.computation(
                        reject,
                        runCatch(
                            x => {
                                const nextTask = f(x);
                                return nextTask instanceof Task
                                    ? nextTask.computation(reject, resolve)
                                    : reject([new Error('flatMap: function must return a Task')]);
                            },
                            rejectWith(reject)
                        )
                    );
                });
            }

            ap(taskValue) {
                return new Task((reject, resolve) => {
                    let fn = null, val = null, fnDone = false, valDone = false;
                    let errors = [];

                    const tryResolve = () => {
                        if (fnDone && valDone) {
                            errors.length > 0
                                ? reject(errors)
                                : runCatch(() => resolve(fn(val)), rejectWith(reject))();
                        }
                    };

                    this.computation(
                        errs => { errors = errors.concat(errs); fnDone = true; tryResolve(); },
                        f => { fn = f; fnDone = true; tryResolve(); }
                    );

                    taskValue.computation(
                        errs => { errors = errors.concat(errs); valDone = true; tryResolve(); },
                        x => { val = x; valDone = true; tryResolve(); }
                    );
                });
            }

            fold(onRejected, onResolved) {
                return new Task((reject, resolve) => {
                    this.computation(
                        runCatch(compose(resolve, onRejected), rejectWith(reject)),
                        runCatch(compose(resolve, onResolved), rejectWith(reject))
                    );
                });
            }

            run(onRejected, onResolved) {
                assertFunctions['task_run'](onRejected);
                assertFunctions['task_run'](onResolved);
                this.computation(onRejected, onResolved);
            }

            toPromise() {
                return new Promise((resolve, reject) => {
                    this.computation(reject, resolve);
                });
            }

            toEither(callback) {
                this.run(
                    compose(callback, left),
                    compose(callback, right)
                );
            }
        }

        // Constructors
        const task = computation => {
            assertFunctions['task'](computation);
            if (computation.length !== 2) {
                raise(new TypeError(
                    `Task: computation must accept exactly 2 parameters (reject, resolve), but got ${computation.length}`
                ));
            }
            return new Task(computation);
        };

        const resolved = x => new Task((_, resolve) => resolve(x));

        const rejected = e => new Task((reject, _) => reject(toErrorArray(e)));

        const fromPromise = promiseFn => (...args) => new Task((reject, resolve) => {
            promiseFn(...args)
                .then(resolve)
                .catch(rejectWith(reject));
        });

        const fromEither = e => e.isRight()
            ? resolved(e.value)
            : rejected(e.value);

        // Combinators
        const all = tasks => new Task((reject, resolve) => {
            const list = useArrayOrLift(tasks);
            if (list.length === 0) return resolve([]);

            const results = [];
            let completed = 0;
            let errors = [];

            const onComplete = () => {
                if (completed === list.length) {
                    errors.length > 0 ? reject(errors) : resolve(results);
                }
            };

            list.forEach((t, i) => {
                t.computation(
                    errs => { errors = errors.concat(errs); completed++; onComplete(); },
                    val => { results[i] = val; completed++; onComplete(); }
                );
            });
        });

        const race = tasks => new Task((reject, resolve) => {
            const list = useArrayOrLift(tasks);
            if (list.length === 0) return reject([new Error('race: empty task list')]);

            const shared = { called: false };
            const onceReject = once(reject, { state: shared });
            const onceResolve = once(resolve, { state: shared });

            list.forEach(t => t.computation(onceReject, onceResolve));
        });

        const taskSequence = tasks => {
            const list = useArrayOrLift(tasks);
            return list.reduce(
                (acc, t) => acc.flatMap(arr => t.map(val => [...arr, val])),
                resolved([])
            );
        };

        const taskTraverse = f => list => taskSequence(useArrayOrLift(list).map(f));
        return {
            core: {
                Types, raise, typeOf, isFunction, isPlainObject, assertFunction, hasFunctions,
                isFunctor, isApplicative, isMonad, identity, constant, tuple,
                apply, unapply, apply2, unapply2, curry, uncurry, curry2, uncurry2,
                partial, predicate, negate, flip, flip2, flipC,
                pipe, pipe2, compose, compose2, once, converge, catch: runCatch, runOrDefault, capture,
                tap, also, into, useOrLift, useArrayOrLift, range, rangeBy,
            },
            either: {
                left, right, catch: eitherCatch, from, fromNullable,
                validate, validateAll, sequence, pipeK, traverse, traverseAll,
            },
            monoid: {
                ...of, isMonoid, fold, concat, invert, power,
            },
            free: {
                pure, impure, isPure, isImpure, liftF,
                runSync, runAsync, trampoline, done, suspend,
            },
            extra: {
                path,
                template,
            },
            task: {
                of: resolved,
                resolved,
                rejected,
                fromPromise,
                fromEither,
                all,
                race,
                sequence: taskSequence,
                traverse: taskTraverse,
                Task,
            },
        };
    };
    return funFpJs;
});
